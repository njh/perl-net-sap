/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.08 from the
 * contents of SAP.xs. Do not edit this file, edit SAP.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "lib/Net/SAP.xs"
/*

	SAP: Session Announcement Protocol (rfc2974) Packet parser

	Nicholas Humfrey
	University of Southampton
	njh@ecs.soton.ac.uk
	
*/

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#include <ifaddrs.h>

#include "mcast_socket.h"
#include "fnv.h"

// rfc2327 says the max size of an SDP file is 1k
#define SAP_BUFFER_SIZE		(2048) 

// for 16bit fnv
#define MASK_16 (((Fnv32_t)1<<16)-1)  /* i.e., (Fnv32_t)0xffff */





//
// Returns a public address of a local inteface
// for specifified protocol family
//

static SV*
get_origin_address( int family ) {
	struct ifaddrs *ifap0, *ifap;
	SV* result = NULL;

	if (getifaddrs(&ifap0)) {
		perror("getifaddrs failed");
		return NULL;
	}


	for (ifap = ifap0; ifap; ifap=ifap->ifa_next) {
	
		// Skip if there is no address
		if (ifap->ifa_addr == NULL)
				continue;
	
		// Skip if it is the loopback interface
		if ( ifap->ifa_flags & IFF_LOOPBACK )
				continue;
		
		// Skip if it isn't the right family
		if (ifap->ifa_addr->sa_family != family)
				continue;
				
		if (ifap->ifa_addr->sa_family == AF_INET6) {
			struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)ifap->ifa_addr;
			
			// Link local v6 address ?
			if (IN6_IS_ADDR_LINKLOCAL( &sin6->sin6_addr ))
				continue;
				
			// Site local v6 address ?
			if (IN6_IS_ADDR_SITELOCAL( &sin6->sin6_addr ))
				continue;
		}
		
		
		
		// Ok, lets try turning it into a string
		{
			char host[NI_MAXHOST];
			int err = -1;
			
			switch (ifap->ifa_addr->sa_family) {
				case AF_INET:
					err = getnameinfo(ifap->ifa_addr, sizeof(struct sockaddr_in),
									  host, sizeof(host), NULL, 0, NI_NUMERICHOST);
				break;
				
				case AF_INET6:
					err = getnameinfo(ifap->ifa_addr, sizeof(struct sockaddr_in6),
									  host, sizeof(host), NULL, 0, NI_NUMERICHOST);
				break;
			}


			// Success ?
			if (err==0) {
				result = newSVpv( host, 0 );
				break;
			}
		}
	}
	
	freeifaddrs( ifap0 );

	return result;
}


#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#line 123 "lib/Net/SAP.c"
XS(XS_Net__SAP__xs_socket_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SAP__xs_socket_create)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Net::SAP::_xs_socket_create(host, port, hops)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char *	host = (char *)SvPV_nolen(ST(0));
	int	port = (int)SvIV(ST(1));
	int	hops = (int)SvIV(ST(2));
	mcast_socket_t *	RETVAL;
#line 122 "lib/Net/SAP.xs"
	RETVAL = mcast_socket_create(
		host,	// host
		port,	// port
		hops,	// ttl
		0		// loopback
	);
#line 143 "lib/Net/SAP.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "mcast_socket_tPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Net__SAP__xs_socket_set_timeout); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SAP__xs_socket_set_timeout)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Net::SAP::_xs_socket_set_timeout(socket, timeout)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	mcast_socket_t*	socket;
	int	timeout = (int)SvIV(ST(1));

	if (sv_derived_from(ST(0), "mcast_socket_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    socket = INT2PTR(mcast_socket_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "socket is not of type mcast_socket_tPtr");
#line 141 "lib/Net/SAP.xs"
  	mcast_socket_set_timeout( socket, timeout );
#line 169 "lib/Net/SAP.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Net__SAP__xs_socket_recv); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SAP__xs_socket_recv)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Net::SAP::_xs_socket_recv(socket)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	mcast_socket_t*	socket;
	HV *	RETVAL;

	if (sv_derived_from(ST(0), "mcast_socket_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    socket = INT2PTR(mcast_socket_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "socket is not of type mcast_socket_tPtr");
#line 156 "lib/Net/SAP.xs"
	char buffer[SAP_BUFFER_SIZE];
	char from[NI_MAXHOST];
	int size;

	size = mcast_socket_recv(
				socket,
				buffer, SAP_BUFFER_SIZE, 
				from, NI_MAXHOST );


	if (size <= 0) {
		XSRETURN_UNDEF;
	} else {
		HV* hash = newHV();
		hv_store(hash, "from", 4, newSVpv(from, 0), 0);
		hv_store(hash, "size", 4, newSViv(size), 0);
		hv_store(hash, "data", 4, newSVpv(buffer, size), 0);
		RETVAL = hash;
		sv_2mortal((SV*)RETVAL);
	}

#line 213 "lib/Net/SAP.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Net__SAP__xs_socket_send); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SAP__xs_socket_send)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Net::SAP::_xs_socket_send(socket, data)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	mcast_socket_t*	socket;
	SV*	data = ST(1);
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "mcast_socket_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    socket = INT2PTR(mcast_socket_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "socket is not of type mcast_socket_tPtr");
#line 190 "lib/Net/SAP.xs"
	STRLEN data_len;
	char * data_ptr;
	data_ptr = SvPV(data, data_len);
	RETVAL = mcast_socket_send( socket, data_ptr, data_len);
#line 244 "lib/Net/SAP.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Net__SAP__xs_socket_close); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SAP__xs_socket_close)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Net::SAP::_xs_socket_close(socket)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	mcast_socket_t*	socket;

	if (sv_derived_from(ST(0), "mcast_socket_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    socket = INT2PTR(mcast_socket_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "socket is not of type mcast_socket_tPtr");
#line 206 "lib/Net/SAP.xs"
	mcast_socket_close( socket );
#line 268 "lib/Net/SAP.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Net__SAP__xs_socket_family); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SAP__xs_socket_family)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Net::SAP::_xs_socket_family(socket)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	mcast_socket_t*	socket;
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "mcast_socket_tPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    socket = INT2PTR(mcast_socket_t *,tmp);
	}
	else
	    Perl_croak(aTHX_ "socket is not of type mcast_socket_tPtr");
#line 218 "lib/Net/SAP.xs"
	RETVAL = mcast_socket_get_family( socket );
#line 293 "lib/Net/SAP.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Net__SAP__xs_ipaddr_to_str); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SAP__xs_ipaddr_to_str)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Net::SAP::_xs_ipaddr_to_str(family, address)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char*	family = (char *)SvPV_nolen(ST(0));
	char*	address = (char *)SvPV_nolen(ST(1));
	SV *	RETVAL;
#line 232 "lib/Net/SAP.xs"
  	if (address==NULL)
  		XSRETURN_UNDEF;
  	if (family==NULL || strlen(family)==0)
  		XSRETURN_UNDEF;

	if (strncasecmp(family, "ipv4", 4)==0) {
		char string[INET_ADDRSTRLEN];
		inet_ntop(AF_INET, address, string, sizeof(string));
		RETVAL = newSVpv( string, 0 );
	} else if (strncasecmp(family, "ipv6", 4)==0) {
		char string[INET6_ADDRSTRLEN];
		inet_ntop(AF_INET6, address, string, sizeof(string));
		RETVAL = newSVpv( string, 0 );
	} else {
		croak("Unknown family passed to _xs_ipaddr_to_str()");
		XSRETURN_UNDEF;
	}
#line 328 "lib/Net/SAP.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Net__SAP__xs_str_to_ipaddr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SAP__xs_str_to_ipaddr)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Net::SAP::_xs_str_to_ipaddr(family, string)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char*	family = (char *)SvPV_nolen(ST(0));
	char*	string = (char *)SvPV_nolen(ST(1));
	SV *	RETVAL;
#line 261 "lib/Net/SAP.xs"
  	if (string==NULL || strlen(string)==0)
  		XSRETURN_UNDEF;
  	if (family==NULL || strlen(family)==0)
  		XSRETURN_UNDEF;

	if (strncasecmp(family, "ipv4", 4)==0) {
		struct in_addr inaddr;
		inet_pton(AF_INET, string, &inaddr);
		RETVAL = newSVpv( (char*)&inaddr, sizeof(inaddr) );
	} else if (strncasecmp(family, "ipv6", 4)==0) {
		struct in6_addr in6addr;
		inet_pton(AF_INET6, string, &in6addr);
		RETVAL = newSVpv( (char*)&in6addr, sizeof(in6addr) );
	} else {
		croak("Unknown family passed to _xs_str_to_ipaddr()");
		XSRETURN_UNDEF;
	}
#line 364 "lib/Net/SAP.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Net__SAP__xs_origin_addr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SAP__xs_origin_addr)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Net::SAP::_xs_origin_addr(family)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	char*	family = (char *)SvPV_nolen(ST(0));
	SV *	RETVAL;
#line 290 "lib/Net/SAP.xs"
  	if (family==NULL || strlen(family)==0)
  		XSRETURN_UNDEF;

	if (strncasecmp(family, "ipv4", 4)==0) {
		RETVAL = get_origin_address( AF_INET );
	} else if (strncasecmp(family, "ipv6", 4)==0) {
		RETVAL = get_origin_address( AF_INET6 );
	} else {
		croak("Unknown family passed to _xs_origin_addr()");
		XSRETURN_UNDEF;
	}
#line 393 "lib/Net/SAP.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Net__SAP__xs_16bit_hash); /* prototype to pass -Wmissing-prototypes */
XS(XS_Net__SAP__xs_16bit_hash)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Net::SAP::_xs_16bit_hash(data)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV*	data = ST(0);
	unsigned short	RETVAL;
	dXSTARG;
#line 315 "lib/Net/SAP.xs"
	STRLEN data_len;
	char * data_ptr;
	Fnv32_t hash;

  	if (data==NULL) XSRETURN_UNDEF;
	data_ptr = SvPV(data, data_len);


	// Calulate a 32bit hash and fold it into 16 bits
	hash = fnv_32_buf(data, data_len, FNV1_32_INIT);
	hash = (hash>>16) ^ (hash & MASK_16);

	RETVAL = hash;

#line 426 "lib/Net/SAP.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Net__SAP); /* prototype to pass -Wmissing-prototypes */
XS(boot_Net__SAP)
{
    dXSARGS;
    char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("Net::SAP::_xs_socket_create", XS_Net__SAP__xs_socket_create, file);
        newXS("Net::SAP::_xs_socket_set_timeout", XS_Net__SAP__xs_socket_set_timeout, file);
        newXS("Net::SAP::_xs_socket_recv", XS_Net__SAP__xs_socket_recv, file);
        newXS("Net::SAP::_xs_socket_send", XS_Net__SAP__xs_socket_send, file);
        newXS("Net::SAP::_xs_socket_close", XS_Net__SAP__xs_socket_close, file);
        newXS("Net::SAP::_xs_socket_family", XS_Net__SAP__xs_socket_family, file);
        newXS("Net::SAP::_xs_ipaddr_to_str", XS_Net__SAP__xs_ipaddr_to_str, file);
        newXS("Net::SAP::_xs_str_to_ipaddr", XS_Net__SAP__xs_str_to_ipaddr, file);
        newXS("Net::SAP::_xs_origin_addr", XS_Net__SAP__xs_origin_addr, file);
        newXS("Net::SAP::_xs_16bit_hash", XS_Net__SAP__xs_16bit_hash, file);
    XSRETURN_YES;
}

